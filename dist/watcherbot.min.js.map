{"mappings":"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","sources":["src/watcherbot.js"],"sourcesContent":["/** @format */\n\nimport Puppeteer from 'puppeteer';\n\nclass WatcherBot {\n\tconstructor({\n\t\turl,\n\t\ttimeToRefresh = 60000,\n\t\tlogEnabled = true,\n\t\tlogDetails = false,\n\t}) {\n\t\t/**\n\t\t *  @private\n\t\t *  @type { String }\n\t\t *\n\t\t *  @description the target url for the bot to watch. The Bot will report when the page changes\n\t\t *\n\t\t */\n\n\t\tthis._target = url;\n\n\t\t/**\n\t\t *  @private\n\t\t *  @type { Number }\n\t\t *\n\t\t *  @description the number of milliseconds between the two versions of the page to compare. Lowering the\n\t\t *  amount may increase network load on the target\n\t\t *\n\t\t */\n\n\t\tthis._refreshCycle = this._assertRefreshCycle({ timeToRefresh });\n\n\t\t/**\n\t\t * \t@private\n\t\t * \t@type { Number }\n\t\t *\n\t\t * \t@description the point in time in ms when the request was initated last\n\t\t */\n\n\t\tthis._lastRequestTimeStamp = undefined;\n\n\t\t/**\n\t\t * @private\n\t\t * @type { boolean }\n\t\t *\n\t\t * @description a boolean indicating if the progress of watching the page should be logged\n\t\t * to the console.\n\t\t */\n\n\t\tthis._logEnabled = logEnabled;\n\n\t\t/**\n\t\t * @private\n\t\t * @type { boolean }\n\t\t *\n\t\t * @description a boolean indicating if the details of watching the page should be logged\n\t\t * to the console.\n\t\t */\n\n\t\tthis._logDetails = logDetails;\n\n\t\t/**\n\t\t * @private\n\t\t * @type { Number }\n\t\t *\n\t\t * @description the amount of times the keepWatching method has been executed, indicating the amount of cycles\n\t\t * completed.\n\t\t */\n\n\t\tthis._watchCycles = 0;\n\t}\n\n\t/**\n\t *\n\t *  @private\n\t *  @description method to assert the time to refresh to be between the supposed parameters. The ttr should not be\n\t *  below 100ms and has no upper bounds\n\t *\n\t *  @param { {} } param0 - the object passed to the method that contains property for the configuration\n\t *  @param { Number } param0.timeToRefresh - the number in seconds between refreshes of the page\n\t *\n\t *  @returns { Number } the number of milliseconds betweeen each refresh\n\t */\n\n\t_assertRefreshCycle({ timeToRefresh }) {\n\t\t// check if the passed argument is not null, undefined or 0\n\n\t\tif (\n\t\t\ttimeToRefresh == 0 ||\n\t\t\ttimeToRefresh == undefined ||\n\t\t\ttimeToRefresh == null\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// the refresh time should be in ms, so the provided argument is mulitplied by 1000 to convert seconds into milliseconds\n\n\t\tconst timeInMs = timeToRefresh * 1000;\n\n\t\t// the minimum time between request should be 100 ms atleast. If the timeInMs is smaller then that, if will be set to 100\n\n\t\treturn timeInMs > 100 ? timeInMs : 100;\n\t}\n\n\t/**\n\t * @property { Number }\n\t */\n\n\tget remainingOffset() {\n\t\tconst now = Date.now();\n\n\t\tconst lastRequest =\n\t\t\tthis._lastRequestTimeStamp == undefined\n\t\t\t\t? now\n\t\t\t\t: this._lastRequestTimeStamp;\n\t\t/**\n\t\t *\n\t\t * The remaining offset is the difference between the current timestamp now and the lastRequestTimetamp added\n\t\t * to the refreshcycle value. The lastRequestTimeTstamp + the refreshCycle value add up to a point in the\n\t\t * future that is then subtracted from the currentTimestamp. If the value is postive, a offset amount remains.\n\t\t * If the value is negative, the request could not be completet before the timer ran out.\n\t\t *\n\t\t */\n\n\t\tconst remainingOffset = lastRequest + this._refreshCycle - now;\n\n\t\tif (remainingOffset > 0) {\n\t\t\treturn remainingOffset;\n\t\t} else {\n\t\t\tconsole.log(\n\t\t\t\t'\\x1b[31m%s\\x1b[0m',\n\t\t\t\t`WatcherBot: The request took ${remainingOffset}ms longer then the specified offset. Timings may not be accurate anymore. Try increasing the 'config.timeToRefresh' value.`\n\t\t\t);\n\n\t\t\treturn this._refreshCycle;\n\t\t}\n\t}\n\n\t/**\n\t *\n\t *  @public\n\t *  @description method that tells the bot to watch for changes in the markup of the element\n\t *\n\t *  @param { {} } param0 - optional object passed to the method to configure the response\n\t *  @param { Function } param0.onChange - method that should be executed when a change in the website is detected\n\t * \t@param { Function } param0.onError - method that should be executed when a error is detected\n\t *\n\t */\n\n\tasync watch({ onChange, onError, navigate } = {}) {\n\t\t/**\n\t\t * @type { Browser }\n\t\t * @description the Browser instance that is created to watch the requestes webpage\n\t\t */\n\n\t\tconst browser = await Puppeteer.launch({\n\t\t\targs: ['--no-sandbox', '--disable-setuid-sandbox'],\n\t\t});\n\n\t\t// create a new broser page and navigate to the inital url\n\n\t\tconst page = await browser.newPage();\n\t\tawait page.goto(this._target);\n\n\t\t// if the onChange method is not undefined, bind this and page and browser to it\n\n\t\tconst onChangeBound = onChange\n\t\t\t? onChange.bind(this, { page, browser })\n\t\t\t: undefined;\n\n\t\t// if the onError method is not undefined, bind this and page and browser to it\n\n\t\tconst onErrorBound = onError\n\t\t\t? onError.bind(this, { page, browser })\n\t\t\t: undefined;\n\n\t\tconst keepWatching = async ({ reload = true } = {}) => {\n\t\t\t// increase the watch cycle count\n\t\t\tthis._watchCycles++;\n\n\t\t\t// reload the page if the reload argument is not false;\n\n\t\t\treload ? await page.reload() : null;\n\n\t\t\tconst remainingOffset = this.remainingOffset;\n\n\t\t\t/**\n\t\t\t * If the logMessages property is set to true, log a message to the console indicating that the bot is\n\t\t\t * still watching.\n\t\t\t */\n\n\t\t\tthis._logEnabled\n\t\t\t\t? console.log(\n\t\t\t\t\t\t'\\x1b[36m%s\\x1b[0m',\n\t\t\t\t\t\t'WatcherBot: Still watching...'\n\t\t\t\t  )\n\t\t\t\t: null;\n\t\t\tthis._logDetails\n\t\t\t\t? console.log(\n\t\t\t\t\t\t'\\x1b[34m%s\\x1b[0m',\n\t\t\t\t\t\t`WatcherBot: Cycle ${this._watchCycles}.`\n\t\t\t\t  )\n\t\t\t\t: null;\n\t\t\tthis._logDetails\n\t\t\t\t? console.log(\n\t\t\t\t\t\t'\\x1b[34m%s\\x1b[0m',\n\t\t\t\t\t\t`WatcherBot: Last cycle was approximately ${\n\t\t\t\t\t\t\tthis._refreshCycle - remainingOffset\n\t\t\t\t\t\t}ms.`\n\t\t\t\t  )\n\t\t\t\t: null;\n\n\t\t\t/**\n\t\t\t *\n\t\t\t * A timeout is set which will execute the navigtate method once the remaining timeout is over. The\n\t\t\t * remaining timeout is calculated from the cycleTimeValue and the last time a request was initated, which\n\t\t\t * is also done when the method is executed\n\t\t\t *\n\t\t\t */\n\n\t\t\tsetTimeout(async () => {\n\t\t\t\tthis._lastRequestTimeStamp = Date.now();\n\t\t\t\tawait navigate({\n\t\t\t\t\tonChange: onChangeBound,\n\t\t\t\t\tonError: onErrorBound,\n\t\t\t\t\tkeepWatching,\n\t\t\t\t\tpage,\n\t\t\t\t});\n\t\t\t}, remainingOffset);\n\t\t};\n\n\t\t/**\n\t\t * Call the keep watching function to initate the watchmode. The watchmode will continue until keepWatching is\n\t\t * no longer called.\n\t\t */\n\n\t\tkeepWatching();\n\t}\n}\n\nexport { WatcherBot };\n"],"names":[],"version":3,"file":"watcherbot.min.js.map","sourceRoot":"../"}